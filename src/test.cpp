#include "../headers/allHeaders.h"

#include <filesystem>
#include <cmath>


// bool Test::FxnOddEven(long vertexId)
// {
//     if(vertexId % 2 == 1)
//         return true;
//     return false;
// }

// bool Test::FxnOddEven_(long v1Id, long v2Id)
// {
//     if((v1Id + v2Id) % 2 == 1)
//         return true;
//     return false;
// }

bool OddEven(long vertexId)
{
    if(vertexId % 2 == 1)      //!! Should be odd, then only true
        return true;
    return false;
//    return true;
}

bool OddEven_(long v1Id, long v2Id)
{
    if((v1Id + v2Id) % 2 == 1) //!Sum should be odd, then only true
        return true;
    return false;
//    return true;
}


std::vector<long> Test::GenerateRandomIntegers(long minInteger, 
                                               long maxInteger, 
                                               long totalNumbers)
{
    srand(100);  //Changed from rand(). srand() seeds rand for you.

    std::vector<long> retV;
    for(long i = 0; i < totalNumbers; ++i)
        retV.emplace_back(rand() % maxInteger + minInteger);

    return retV;
}    

void Test::TestVertexSubset(Graph &g,
                      VertexSubset &vs,
                      long nodesCountInSubset,
                      std::string &logFile)
{
    std::fstream fileStream(logFile, std::ios::app);

    //fileStream << "Beginning the test vertex subset function" << std::endl;

    //!Set this vertex subset
    std::vector<long> subsetIds = GenerateRandomIntegers(0,
                                               g.getNumberVertices(),
                                               nodesCountInSubset);

    std::sort(subsetIds.begin(), subsetIds.end());
    subsetIds.erase(std::unique(subsetIds.begin(), subsetIds.end()), subsetIds.end());

    vs.setVertexSubset(subsetIds);
    fileStream << "Number of vertices: "<< vs.getVertexSubsetLength() << " | Outdegree: " << vs.getVertexSubsetOutDegree(g) << std::endl;
    //fileStream << "Below is the input vector subset:" << std::endl;
    vs.LogIntoFile(fileStream);

    VertexSubset o = Interface::VertexMap(vs, &OddEven);
    VertexSubset o1 = Interface::EdgeMapSparse(g, vs, &OddEven_, &OddEven);
    VertexSubset o2 = Interface::EdgeMapDenseWrite(g, vs, &OddEven_, &OddEven);
    //!Error between edge map sparse and edge map dense should be zero
    bool thereIsAnError = false;
    if(o1.getVertexSubsetLength() != o2.getVertexSubsetLength())
    {
        //!If length is different, flag this error
        fileStream << "Different sizes generated by edgeMapSparse and edgeMapDense" << std::endl;
        thereIsAnError = true;
    }
    else
    {
        for(size_t i = 0; i < o1.getVertexSubsetLength(); ++i)
        {
            long error = o1.getVertexSubset()[i] - o2.getVertexSubset()[i];
            if(error != 0)
            {
                fileStream << "Different subsets generated by edgeMapSparse and edgeMapDense" << std::endl;
                thereIsAnError = true;
                break;
            }   
        }
    }
    fileStream << " " << std::endl;
    fileStream << " " << std::endl;    
//     //Testing: VertexMap
//     //std::cout << "Vertex Map Function output: " << std::endl;
//     VertexSubset o = Interface::VertexMap(vs, &OddEven);
//     //o.printVertexSubset();
//     //std::cout << "After calling Vertex Map Function" << std::endl;

//     //Testing EdgeMapSparse
// //    std::cout << "Before calling Edge Map Sparse Function" << std::endl;
//     VertexSubset o1 = Interface::EdgeMapSparse(g, vs, &OddEven_, &OddEven);
// //    o1.printVertexSubset();
// //    std::cout << "After calling Edge Map Sparse Function" << std::endl;

//     //Testing EdgeMapDense
// //    std::cout << "Before calling Edge Map Dense Function" << std::endl;
//     VertexSubset o2 = Interface::EdgeMapDenseWrite(g, vs, &OddEven_, &OddEven);
// //    o2.printVertexSubset();
// //    std::cout << "After calling Edge Map Dense Function" << std::endl;

//     //!Error between edge map sparse and edge map dense should be zero
//     bool thereIsAnError = false;
//     if(o1.getVertexSubsetLength() != o2.getVertexSubsetLength())
//     {
//         //!If length is different, flag this error
//         thereIsAnError = true;
//     }
//     if(thereIsAnError == true)
//     {
//         std::cout << "Error Present" << std::endl;
//     }

//     for(size_t i = 0; i < o1.getVertexSubsetLength(); ++i)
//     {
//         long error = o1.getVertexSubset()[i] - o2.getVertexSubset()[i];
//         if(error != 0)
//         {
//             thereIsAnError = true;
//             break;
//         }   
//     }

//     if(thereIsAnError == true)
//     {
//         std::cout << "Error Present" << std::endl;
//     }

//     std::cout << std::endl;
//     std::cout << std::endl;
}

void Test::DoTestingOnThisGraph(Graph &currGraph, std::string &logFile)
{
    long verticesCount = currGraph.getNumberVertices();

    std::vector<long> individualSubsetSizes;
    for(int i = 1; i <= 10; ++i)
    {
        long subSetSize = std::ceil(verticesCount * i * 10./100);
        individualSubsetSizes.push_back(subSetSize);
    }
    individualSubsetSizes.erase(std::unique(individualSubsetSizes.begin(), individualSubsetSizes.end()), individualSubsetSizes.end());

    for(auto &subSetSize : individualSubsetSizes)
    {
        VertexSubset vs;

        std::fstream fileStream(logFile, std::ios::app);
        //fileStream << "Beginning of the testing on this graph function" << std::endl;
        fileStream << " " << std::endl;
        //fileStream << "Percentage of nodes selected for subset: "  << i * 10 << "%" <<std::endl;

        TestVertexSubset(currGraph,
                         vs,
                         subSetSize,
                         logFile);

        //fileStream << "Ending of the testing on this graph function" << std::endl;
        fileStream << " " << std::endl;

    }
}