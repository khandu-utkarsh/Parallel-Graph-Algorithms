#include "../headers/allHeaders.h"

#include <filesystem>
#include <cmath>

#include <chrono>


// bool Test::FxnOddEven(long vertexId)
// {
//     if(vertexId % 2 == 1)
//         return true;
//     return false;
// }

// bool Test::FxnOddEven_(long v1Id, long v2Id)
// {
//     if((v1Id + v2Id) % 2 == 1)
//         return true;
//     return false;
// }

bool OddEven(long vertexId)
{
    if(vertexId % 2 == 1)      //!! Should be odd, then only true
        return true;
    return false;
//    return true;
}

bool OddEven_(long v1Id, long v2Id)
{
    if((v1Id + v2Id) % 2 == 1) //!Sum should be odd, then only true
        return true;
    return false;
//    return true;
}

Test::Test(std::string  &currPath,
           std::string &dataFileName)
{
    p_currPath = currPath;
    p_dataFileName = dataFileName;
}


std::vector<long> Test::GenerateRandomIntegers(long minInteger, 
                                               long maxInteger, 
                                               long totalNumbers)
{
    srand(100);  //Changed from rand(). srand() seeds rand for you.

    std::vector<long> retV;
    for(long i = 0; i < totalNumbers; ++i)
        retV.emplace_back(rand() % maxInteger + minInteger);

    return retV;
}    

void Test::TestVertexSubset(Graph &g,
                      VertexSubset &vs,
                      long nodesCountInSubset,
                      std::string &logFile)
{
    std::fstream fileStream(logFile, std::ios::app);

    //fileStream << "Beginning the test vertex subset function" << std::endl;

    //!Set this vertex subset
    std::vector<long> subsetIds = GenerateRandomIntegers(0,
                                               g.getNumberVertices(),
                                               nodesCountInSubset);

    std::sort(subsetIds.begin(), subsetIds.end());
    subsetIds.erase(std::unique(subsetIds.begin(), subsetIds.end()), subsetIds.end());

    vs.setVertexSubset(subsetIds);
    fileStream << "Number of vertices: "<< vs.getVertexSubsetLength() << " | Outdegree: " << vs.getVertexSubsetOutDegree(g) << std::endl;
    //fileStream << "Below is the input vector subset:" << std::endl;
    vs.LogIntoFile(fileStream);

    //VertexSubset o = Interface::VertexMap(vs, &OddEven);
    VertexSubset o2 = Interface::EdgeMapDenseWrite(g, vs, &OddEven_, &OddEven);

//    std::cout << "Dense Done" << std::endl;
    VertexSubset o1 = Interface::EdgeMapSparse(g, vs, &OddEven_, &OddEven);
//    std::cout << "Sparse Done" << std::endl;

    //!Error between edge map sparse and edge map dense should be zero
    bool thereIsAnError = false;
    if(o1.getVertexSubsetLength() != o2.getVertexSubsetLength())
    {
        //!If length is different, flag this error
        fileStream << "Different sizes generated by edgeMapSparse and edgeMapDense" << std::endl;
        thereIsAnError = true;
    }
    else
    {
        for(size_t i = 0; i < o1.getVertexSubsetLength(); ++i)
        {
            long error = o1.getVertexSubset()[i] - o2.getVertexSubset()[i];
            if(error != 0)
            {
                fileStream << "Different subsets generated by edgeMapSparse and edgeMapDense" << std::endl;
                thereIsAnError = true;
                break;
            }   
        }
    }
    fileStream << " " << std::endl;
    fileStream << " " << std::endl;    
//     //Testing: VertexMap
//     //std::cout << "Vertex Map Function output: " << std::endl;
//     VertexSubset o = Interface::VertexMap(vs, &OddEven);
//     //o.printVertexSubset();
//     //std::cout << "After calling Vertex Map Function" << std::endl;

//     //Testing EdgeMapSparse
// //    std::cout << "Before calling Edge Map Sparse Function" << std::endl;
//     VertexSubset o1 = Interface::EdgeMapSparse(g, vs, &OddEven_, &OddEven);
// //    o1.printVertexSubset();
// //    std::cout << "After calling Edge Map Sparse Function" << std::endl;

//     //Testing EdgeMapDense
// //    std::cout << "Before calling Edge Map Dense Function" << std::endl;
//     VertexSubset o2 = Interface::EdgeMapDenseWrite(g, vs, &OddEven_, &OddEven);
// //    o2.printVertexSubset();
// //    std::cout << "After calling Edge Map Dense Function" << std::endl;

//     //!Error between edge map sparse and edge map dense should be zero
//     bool thereIsAnError = false;
//     if(o1.getVertexSubsetLength() != o2.getVertexSubsetLength())
//     {
//         //!If length is different, flag this error
//         thereIsAnError = true;
//     }
//     if(thereIsAnError == true)
//     {
//         std::cout << "Error Present" << std::endl;
//     }

//     for(size_t i = 0; i < o1.getVertexSubsetLength(); ++i)
//     {
//         long error = o1.getVertexSubset()[i] - o2.getVertexSubset()[i];
//         if(error != 0)
//         {
//             thereIsAnError = true;
//             break;
//         }   
//     }

//     if(thereIsAnError == true)
//     {
//         std::cout << "Error Present" << std::endl;
//     }

//     std::cout << std::endl;
//     std::cout << std::endl;
}

void Test::DoTestingOnThisGraph(Graph &currGraph)
{
    long verticesCount = currGraph.getNumberVertices();

    //!Select 30 percent of nodes at random
//    std::vector<long> randomSourcesIndeices = GenerateRandomIntegers(0, verticesCount - 1,std::floor(verticesCount * 5/10));
    std::vector<long> randomSourcesIndeices = GenerateRandomIntegers(0, verticesCount - 1,std::floor(10));    
    //std::vector<long> randomSourcesIndeices {1};
    //! Looping over every source node
    // for(auto currSource: randomSourcesIndeices)
    // {
    //     Tesgit tBFS(currGraph,currSource);
    // }

    // if(g_sourceVertices.size() != 0)
    // {
    //     std::string loggerName = std::string("/test/summary_bfs_") + p_dataFileName;
    //     std::string summaryBFSLog = p_currPath + loggerName;
    //     std::fstream bfsstream(summaryBFSLog, std::ios::out);
    //     //!Print the summary log
    //     bfsstream << "File Name " << " ThreadsCount" << " SourceVertex" << " SeqTime" << " ParTime" << " SpeedUp" << " LayersCountMax" << " Status" << std::endl;
    //     for(size_t i = 0; i < g_sourceVertices.size(); ++ i)
    //     {
    //         bfsstream << p_dataFileName << " " << g_threads[i] << " " << g_sourceVertices[i] << " " << g_seqParTimes[i].first << " " << g_seqParTimes[i].second << " " << g_speedUps[i] << " " <<  g_maxLayersCount[i] << " " << g_compSuccess[i] << std::endl;
    //     }
    // }

    // //!BF
    for(auto currSource: randomSourcesIndeices)
    {
        //!Testing BF
        TestBF(currGraph,currSource);
    }
    // if(g_sourceVertices.size() != 0)
    // {
    //     std::string loggerName = std::string("/test/summary_bfs_") + p_dataFileName;
    //     std::string summaryBFSLog = p_currPath + loggerName;
    //     std::fstream bfsstream(summaryBFSLog, std::ios::out);
    //     //!Print the summary log
    //     bfsstream << "File Name " << " ThreadsCount" << " SourceVertex" << " SeqTime" << " ParTime" << " SpeedUp" << " LayersCountMax" << " Status" << std::endl;
    //     for(size_t i = 0; i < g_sourceVertices.size(); ++ i)
    //     {
    //         bfsstream << p_dataFileName << " " << g_threads[i] << " " << g_sourceVertices[i] << " " << g_seqParTimes[i].first << " " << g_seqParTimes[i].second << " " << g_speedUps[i] << " " <<  g_maxLayersCount[i] << " " << g_compSuccess[i] << std::endl;
    //     }
    // }


    if(b_sourceVertices.size() != 0)
    {
//        std::string summaryBFSLog = p_currPath + std::string("_") +p_dataFileName + std::string("/test/summary_bf_log.txt");
        std::string loggerName = std::string("/test/summary__bf_") + p_dataFileName;
        std::string summaryBFSLog = p_currPath + loggerName;
        std::fstream bfsstream(summaryBFSLog, std::ios::out);
        //!Print the summary log
        bfsstream << "File Name " << " ThreadsCount" << " SourceVertex" << " SeqTime" << " ParTime" << " SpeedUp" << " Status" << std::endl;
        for(size_t i = 0; i < b_sourceVertices.size(); ++ i)
        {
            bfsstream << p_dataFileName << " " << b_threads[i] << " " << b_sourceVertices[i] << " " << b_seqParTimes[i].first << " " << b_seqParTimes[i].second << " " << b_speedUps[i] << " "  << " " << b_compSuccess[i] << std::endl;
        }
    }
}


bool Test::CompareLayers(Graph &currGraph, std::deque<long> &layers, std::deque<long> &layers_s)
{
//    std::cout << "Inside compare layers" << std::endl;
    for(long i = 0; i < layers.size(); i++)
    {
        if(layers[i] != layers_s[i])
        {
//            p_currFileStream << "Layers MisMatch at vertex" <<i  << " |Data val: " << currGraph.getVertexPointer(i)->getDataValue() <<std::endl;
            //std::cout<<"Layers MisMatch at vertex"<<i<<std::endl;
            return false;
        }           
    }

//    std::cout << "Exiting compare layers" << std::endl;
    //std::cout<<"Layers Match!"<<std::endl;
    //p_currFileStream << "Layers Matched!" <<std::endl;
    return true;
}

void Test::TestBFS(Graph& currGraph, long root)
{
    extern std::deque<long> parents;
    extern std::deque<long> layers;
    extern std::deque<long> parents_s;  //!Sequential
    extern std::deque<long> layers_s;   //!Sequential

    auto startS = std::chrono::high_resolution_clock::now();
    bfs_s(currGraph, root);
    auto startE = std::chrono::high_resolution_clock::now();
    auto seqT = std::chrono::duration<double>(startE - startS);

    std::vector<int> p_numThreads;
    std::vector<double> p_parallelTimesBFS;
    std::vector<double> p_speedUpBFS;
    std::vector<long>   p_maxLayersCount;
    std::vector<bool> p_comparisonSuccess;

    std::string fulLogPath = p_currPath + std::string("/test/log_bfs_") + std::string("source_index_") + std::to_string(root) + std::string("_file_name_") + p_dataFileName;
    std::fstream fileStream(fulLogPath, std::ios::out);

//    fileStream << "================" << std::endl;
//    fileStream << "================" << std::endl;
//    fileStream << "New Run" << std::endl;
//    fileStream << "Current Source Index " << root << std::endl; 
//    fileStream << "Testing BFS" << std::endl; 
    fileStream << "File Name " << " SourceVertex" << " ThreadsCount" << " SeqTime" << " ParTime" << " SpeedUp" << " Status" << std::endl;
    //!Looping over threads
    const int maxThreads = 64;
    std::vector<int> threads {2,4,8,16,32,64};

//    for(int iThreads = 1; iThreads <= maxThreads; ++iThreads)
    for(auto currThreadsCount : threads)
//    for(int iThreads = 1; iThreads <= maxThreads; ++iThreads)    
    {
        //int currThreadsCount = iThreads;
        //!Testing BFS
        auto startP = std::chrono::high_resolution_clock::now();
        bfs(currGraph, root, currThreadsCount);
        auto end = std::chrono::high_resolution_clock::now();
        auto parallelT = std::chrono::duration<double>(end - startP);

        auto maxElemIter = std::max_element(layers.begin(), layers.end());

        //!Will be pushed each time with number of threads
        p_numThreads.push_back(currThreadsCount);
        p_parallelTimesBFS.push_back(parallelT.count());
        p_speedUpBFS.push_back(seqT.count()/parallelT.count());
        p_maxLayersCount.push_back(*maxElemIter);

        bool compSuccess = CompareLayers(currGraph, layers, layers_s);
        if(compSuccess)
        {
            //fileStream << "Correctly ran for source vertex: " << root <<" |Data val: " << currGraph.getVertexPointer(root)->getDataValue() <<std::endl;

        }
        else
        {
            fileStream << "Layers MisMatch at vertex" << root  << " |Data val: " << currGraph.getVertexPointer(root)->getDataValue() <<std::endl;
        }
        p_comparisonSuccess.push_back(compSuccess);
//        fileStream << std::endl; 
//        fileStream << std::endl;
        fileStream << p_dataFileName << " " << root<< " " << currThreadsCount << " " << seqT.count() << " " << parallelT.count() << " " << seqT.count()/parallelT.count() << " " <<  compSuccess << std::endl;
    }


    // //!Find maximum speed up element in bfs:
    if(p_speedUpBFS.size() != 0)
    {
        auto bfs_max_speedup = std::max_element(p_speedUpBFS.begin(), p_speedUpBFS.end());
        size_t index = bfs_max_speedup - p_speedUpBFS.begin();

        g_threads.push_back(p_numThreads[index]);
        g_seqParTimes.push_back(std::make_pair(seqT.count(),p_parallelTimesBFS[index]));
        g_sourceVertices.push_back(currGraph.getVertexPointer(root)->getDataValue());
        g_maxLayersCount.push_back(p_maxLayersCount[index]);
        g_speedUps.push_back(p_speedUpBFS[index]);
        g_compSuccess.push_back(p_comparisonSuccess[index]);
    }
}


bool Test::CompareSPs(Graph &currGraph, std::deque<double> &SP, std::deque<double> &SP_s)
{
    for(long i = 0; i < SP.size(); i++)
    {
        if(SP[i] != SP_s[i])
        {
            //std::cout<<"SP MisMatch at vertex "<<i<<std::endl; 
//            p_currFileStream <<"BF -> SP MisMatch at vertex: "<<i  << " |Data val: " << currGraph.getVertexPointer(i)->getDataValue() <<std::endl; 
            return false;
        }
           
    }
    //std::cout<<"SPs Match!"<<std::endl;
    return true;
}
void Test::TestBF(Graph& currGraph, long root)
{
    extern std::deque<double> SP;
    extern std::deque<long> Visited;
    extern std::deque<double>SP_s;
    extern std::deque<long> Visited_s;

    //std::cout<<"It all starts here\n";
    
    auto startS = std::chrono::high_resolution_clock::now();
    bellmanFord_s(currGraph, root);   //!Call this seq with number of threds are 1
    auto startE = std::chrono::high_resolution_clock::now();
    auto seqT = std::chrono::duration<double>(startE - startS);

    std::string fulLogPath = p_currPath + std::string("/test/log_bf_") + std::string("source_index_") + std::to_string(root) + std::string("_file_name_") + p_dataFileName;
    std::fstream fileStream(fulLogPath, std::ios::out);


    std::vector<int> p_numThreads;
    std::vector<double> p_parallelTimesBFS;
    std::vector<double> p_speedUpBFS;
    std::vector<bool> p_comparisonSuccess;
//    fileStream << "Testing BF" << std::endl; 

    //!Looping over threads
    const int maxThreads = 64;
    std::vector<int> threads {2,4,8,16,32,64};
    fileStream << "File Name "  << " SourceVertex" << " ThreadsCount" << " SeqTime" << " ParTime" << " SpeedUp" << " Status" << std::endl;
    for(auto currThreadsCount : threads)
//    for(int iThreads = 1; iThreads <= maxThreads; ++iThreads)
    {
        auto startP = std::chrono::high_resolution_clock::now();
        bellmanFord(currGraph, root, currThreadsCount);   //!Parallel with num of threads more than 1
        auto end = std::chrono::high_resolution_clock::now();
        auto parallelT = std::chrono::duration<double>(end - startP);

        //std::cout << "Seq Time: " << seqT.count() << " Parallel Time: " << parallelT.count() << std::endl;
        bool compSuccess = CompareSPs(currGraph, SP, SP_s);

        p_numThreads.push_back(currThreadsCount);
        p_parallelTimesBFS.push_back(parallelT.count());
        p_speedUpBFS.push_back(seqT.count()/parallelT.count());
        if(compSuccess)
        {
            int temp = 0;
        }
        else
        {
            fileStream <<"BF -> SP MisMatch at vertex: "<<root  << " |Data val: " << currGraph.getVertexPointer(root)->getDataValue() <<std::endl; 
        }
        p_BF_comparisonSuccess.push_back(compSuccess);
        fileStream << p_dataFileName << " " << root << " " << currThreadsCount << " " << seqT.count() << " " << parallelT.count() << " " << seqT.count()/parallelT.count() << " " <<  compSuccess << std::endl;
    }

    // //!Find maximum speed up element in bf:
    if(p_speedUpBFS.size() != 0)
    {
        auto bfs_max_speedup = std::max_element(p_speedUpBFS.begin(), p_speedUpBFS.end());
        size_t index = bfs_max_speedup - p_speedUpBFS.begin();

        b_threads.push_back(p_numThreads[index]);
  
        b_seqParTimes.push_back(std::make_pair(seqT.count(),p_parallelTimesBFS[index]));
        b_sourceVertices.push_back(currGraph.getVertexPointer(root)->getDataValue());
        b_speedUps.push_back(p_speedUpBFS[index]);
        b_compSuccess.push_back(p_BF_comparisonSuccess[index]);
    }

}